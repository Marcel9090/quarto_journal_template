<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"94222f0b04afd18b53c5ef70dc971311e7d5263184f23af4cb4aa075c32ab07230c04ff90ce752f6a7a0630e4637952f5f2bc79d1b05697ff04daae6d886c194375a2c5926453856ff310af7c5ad1e4f9b354ac43f3d7079fa5ec5a6a198609e49917d800bbedfd6769067e0ad0336d9f779603d565b73b7e1f4fb264668c4e1de367a29b734ffaf57a9f924fe44f84764351e0c1a417827721c082462ba21bc9c335f6c8c43474b54048187915efec94d1fcc319f3c94bb0d669e0e343dd0f8a9e1301d6c18af7b30acbe4cf5c5d56494f124e0adac9d545bcbc32fe84c999f5b73719ab16445517dd263fae6a2eb74c556e9e3225827671016110baf202b91ead166bcc5bd8fc62f74fe908e4611cc3d4d8ede76633141ef84cfb0ee353a17f53fd0cdf3ef013e1c8fb1e7b72259fbd7ec9cee6e8fd67c85492093910f282391a7e84afe7cffa89593646e275b36cde526329ea43f8a532d5422ced0c3713ea6e59003a8433162621adaba8a81d1d3df49093ec18a06f6825205e48fc0f1e7625ef89cd441a10966b68f51e5bbc4347a9fff7ef538110a0ca8d7683a39871260e304e27e1a198658b377fabce53540527b86db53e702f9e63ee32667c15359529cd3c1b9fec5005a998e69b21cd65899a0f9e0c6c8ac64babd56cbd7310af50168ef3a8c114368deba5cd1181fcaf56772466f36087588a05c5fad4f9630c2cf838e2c282140045ac2aae39c3e413151b0d72327fcb12c23a8fcea74f927dc89a0dda68760c2cf9930777ba7187a95cd5ec35c199dec5de8b7e38bc14cca75246c0c6513a76512cc9feb11c6c67f5462bf1f46ace9710f12b909fa74b97eec58794b9c31ed1e3ff053711ec00533adc725fc1dbea3d8938b1968e0200b21318cc284940ad43a52b1d66d7607181f93a0d689ab07375d7ba3c787dd11e607634eb26f4803af2869cf2c6e322f7de5f0e87d6ab55d9ff7ac1cac57daed469ac67faf557cb4d73465887b2970c21a5653e973500f24c23ad9c95dcdf3c13daf631e78d83c6c87ed743be9d94f348dbc903a5c60e9418bf29b971b5baccff70bdcf076908d54a4ba6b79643f2983cb782047fdfd3f3018be76c4f942b83ad8cce746d9a8a0bcea841d28487ebaa058df349439f9069505cc6078ca8dd97ea408ecef13909125b404185f2f2e8bd6ebffe5d4248e7144a6e8a3962e0772a9abe1116b1ab6b2c0e660a9d81bee2ec5a5a420e9a188ca949233c14b6fde7354bcfe84a7b68100d3a24b215e5ca9f19350c382e7c6862f115cc617c3c525ca7c6c4ae45f4f5e67bc21bf1fdf1d6e06291cdce066e33168cc21ac06308ed29b6b1926916049fe02387b8e3b6db2222b7eac334c52a4bcfe4bf972140e97738afe07a7450075af80621cf0f34cead9717581a1ee058311e501fdc0beb9c9f8baf3fe0b19195f452811d255cbf55acbf6736e25b209f56fa387347098195c465879c559ea2a9dafa749bc2696c412312d8f77aa4d146c1d9bae8e7c8651637f869abc9c645a4a13ab0dcdf3a3cc66b0ebd99a98ed0e4dee006fed083145807b4e1bc7df1d21213bf4e6999f6351fba1cc693df31a022d57120a411dcfdfda030fac219a6399de6e77250203e11e76e8efc001fd4a824c40a4439c641e208e872ebaef3fbcb41396d9a96448129306a30410954e520dac9325ca0a36cd446d325d1e50862b9966932caf79230cc8d387a5460086cd8feb384bfb8556cb85524b9ff3cca8446468195fe5682ea1b66fe9ac0f128a68da317aeba924c56d6f18940e1f21f9d46bc0d72adfabe5bede26ce7e10f3c3759ed7e7aaf9b62005643bf12534e5f030dafc04e4e0ccb3aec4736fe67ca472f3fd0270a41e8f2aa8018a1024262cfec29a1ef88edbf15e34cc60cf75c76c74dc2497cb216e3d98096ab4ecaf9c5484553880b2be4257b93037752cd1db58db557c1415f445a025bb709d478db51103c2b7fc3eab515f586cf45b0aa4a19999b1c676ce180c66efd67a94b2c77d2221f297385a6da50aa3a556ac85fdb5e4f709492acbc452de3ff54fecf58720c3bb6bd402cf7bf2400de701bc193db8cd5814901e9767f906585d4cabc6f0db9b51b52b11eb1c3a0d65f3807f1104b53f8cb3a771865db96245da04ef0bf9c1fbdcc35699fa4f03c7493c48624bdd9db0bbcad7d8d3e5ae52845b1bf4db6c39610cce0909fe3da31bdafc9cffe71fa0a409e563f2ed5112221ff053337e2aa3c3f86170bbebbd7f64565bf1c29108e7243f42115cc0b73435b64c1cd3ae913f570106fac70e8cd37a058e319d0c5367e35583f1316e9cf4d4b067bfae5def814a700f1962b6f0576056769cbd5db1fe77b2bf82347f856f4adb2aaab816a0f8dc8ed33b96d5498126f1cb9bf0b5f24ad4ba6d11c12b4a22c5b10851c0d87ac191f1a16c4d4ccd007ee1f5ef05eeaf8333799aaad44d65f728937dccc98ddfc364a442a7941f8968a5c2df840b1bacadc736a727f3f5ecfaa11ca34282fadfc732c3c3b3ddfee34a76552ed53d79a13d8cdfab859766e291f78f5680c903c9fefcc7fb44c51dabbcbf5df7fa894d48026819f8d8a772105401eb16e85eedb63687a387524ab1b85e1f80685e79f7e34b681d0a4b625c080590edf6559502cdb8cf520fc397b32eb5d5195c3a72f3244e252a6ede4851ca28a9122b9d3384adc8c7e68009f1ddf59f46b69006744b4ff4cc0cbe848c9ae7849d3444e47eb68617124d70d2d0e8ba3e63d6fe8f032ac62f51f63007e2ae105c08cc95400c646e1a617c10ad302a64edd25a61f0bd89cf28f714502199d5ba42b6cf4b8f2cf90d4d74255114b050446e5d96916196050e4c13e88c6a6d8bdc1b948e00b1e39102d174e6e32466ab20e05100f3c84eff58b4869bdc136c8e625fea0d4f4beb406cf8b81d21270d0af11c4f0b142192927f102653653bd3ceb218b7b448160dd80850277caec97319709d98b5811a62de86317e9044124d3dcbee4d5bf7b99d3358966b3ed9b58e326f2f73cb5a9f8002de28920de6b885f3526b63a039973ac9780f6418755198e00abb3ec7b6ae1b1769c0f4a83dc0660b66b7d072c6414306f9d5018d15f0dc0d018360494efccca556b5b146f8e5c9ac062645f24d1e2c8c73fda6bbf07fb03262f59f73ed92b0b85145a28fe2855a84fa09d3f9906d3f3df1b994fc19f6c0b72a2b06babd965aa33fc512eb5174402b5cecd6779beeefbc4798037143fc491a4b7e55813b7078494904faf6b4e5a94c6cb27ef2527c0c2666d3defaaf79baf5d2b5a41d3a7d1f4633669bb3feaf49d67a539cffc65597a911f0326aabaa8f9669df573d672a4f9b46dcc44e17c063fb87cef04733fad900fc9acca0576624e654d0ad50909ccf2b9947addc830ca9daaaa0c3d0d8906ae06ded123608a5debea6065ca2202cf7d9d8725aac706f5f52d0a89bacd27b0678d0ab141270aa1d74476a6c7af7b981c6227698a582f3d6a78a1ecf632b1ce29c7b9d00cfaf4dda6c73113e2517f0c0a68923bef982b76559855ea0524db53e278d56b943cdf8726f554ae8e9a21d7a4f336d2ea172ac1f17e8d4b9e4a70859559736d9f20f0e03460ca2be52b7d1b7363b74c18f46cb91201052907e4016e42d8180d494b97bcbd331e7f20590bcc5e2e1d3fc4fc9d74b182f907a827246dfa2558d48f964662c325a40acdadba340eb1b2e387f59af26df63da02d7b8d1afcb0b6b8d2ce982ba72fcc8151144df157d96dee36eacb7901bb0b4ac307c7f66097ddb41e01c8e434e00293a62bac8d9487e8ec667be8ceb572795b893fd79a436894b562a4f8dd2c1ea92e6c882e46b831e2ca7720545b7f95a294bdb0fd8452215266c158e89a0243f387e83356fb91b0c35283299fafbf69da8d6e1066f2c58da5ce304eec9e9a5f145a808e10367e149b82781398fd803724458ad6d53774e345c074acf20924de6f3a2cf4e5e50e92f847bdab2fce9a9ea4fc31755b2ea76dc69fb3e8e4c7356c2330156590ce2fa7cc5fcaa2e9b76c677f339bf297238c4fa111d7be111351ad1e33a0eecd4f8699cdb96c0726091a2ab2c53c68733817bd6985d2ca79cb6ba246f8841b7299fa8a89acaf2a7dbe3024b6b274b512b0642fdc907a51ce9cc9cbb8d7055895b28f1982a86a90f2c679d09462880009b1249f2d0c6c1c59ba98bd35f105165bdee239432109a2b3eb6e0a2d0465c33df600aa4c5a9f3077114b13d199d98eedad118d587fa3a00ccb22990c9a49a364f7d664bcefdde917d230b083702524b22c0e2aac3e29dafa7c8ab6db4f13bdb8445c11c76680356666f7c9d3d641043d4e9cdb2ae6254405d7d688196e0f37c9db54dae766cf9816f883dc2b83a36f24dea5f47a69edafaa3d8f239c6975850d02f03eaea633b3a3d53c05d3191dbca973047f4a58f46c1cdcac0cfbe900b3e24f1f07641cabfd481dad6fd929564cb3c2cc4cd10a31742a58e63d2796d9abfe404dfc928b453a96ee27440272ffa4873fdc723fe4b9fee897e4e63528ea47fc23db6fc7130b65fb8647682e8481e8da32011ca73fb8e60f8bdfea5bfcefc2a77bc28b204a14d1d37191e512e15422afe29e941c79c8fa7fcb7d084e80f226e243c6015ce48f72bd728562b4a5a20b543b80eea5639b7a7cb79880add387b0f6c866381465f6a22d9387a42554b4af268d3dc83b5cf01120ba416c78620d4898f9e410f83c7e9bb234d6354e290729b02704493aee48c9adce861a00c83ee975d9345a7a4a210781b13d0ed6267195676ddd3f08122e2106bcfe5b1d8ef1e935bac31b3968dda97ec469ec968ab9aab28fcd490e245fc72fb5cd33f654dbc24945e691eb3705a505e2773f155e4c9fe8fffd678caeb0a8b1171559b25f4c05234d276b78b31ea94131addbc9aa78c93a80573e554a610393b6d270f2fd8cb558434c0fb5a1c5f4caeb8a82043ae0516b1bc62c3e9c93e97a0208db9654793631d7304f9c8e3ab2e0d410f235e49709608799bc9781feb29d13aaf3928365b02f98ed44f4ffed4dedd207690652acb42686f9723b54b23b98ea0f75a688778e1a3136aa1e00c7737f636ba1ea23f9f8b11d59555c63bbb3080e5e16e3d9c23275ee764e94414fe342120b5782f592668d86b9036cd4970dc115f897a0f301145af3dd035a149778b65f5c836d6e3ffe7d792a3a53a4db7810f38cad92d69b3a231bfcca22a29343ae4a26c96c51296004746eabfecfcf9c44f8c9c9a03d1d52ca6fb82c810cda8614ea58bb6ad9ea0df01b781c8b6a3a338834f9d5bdd44028e95b31056546b4d0c3980490a0df60c3a9527a12e8cf0d6ab5337b1bc2973d3d3f81242be414a2d2a8983a39df8ef1a918a1300559a5f778dcc8218f910e340bc059b58c26c17d1caef10c5bdee3722c3bb00dd7a260debd62fe49aa2a6dc8911b339898196c88625bf11c2f6ce443468fcf085c74932adcc079c7efef7e642b94eac5cd5065ea8eb2e019213a9a31b13f5e9530bde9ee29ff30bfd75663119a3e1f13c103fdd25bc7c4f49fb0ad75d3b3f7cdc3bd4e12974d54c4b7fb517a482df4917fcbace9939c713e8d7f44d5fb60f8393b703fedecfa28fccba46e6d76abeff86d192de07f95d39bdce1d80107a7f0a71a536e72448800151721c1f9d40b92593d94f91c7a5c886c9a7afbd342ad57b0a7f249e23ce078ffba24bb49536db17f47015e69778661a2d4c2cf44243a87bc778b78496cb579bb1903614a91893e04112b0d0f5997488778136a8abd00836dff0a613ba6ba19bce1cd9d3295bdceabce99823215cafc50021c4a554bc795724943036be28029a4af02b1a5d10d8c131ec3443941dcaf819bd11ef18a253d94eec9934e8ca1eb38ce9f5e4b88f4e50ecb0d3b75a346361ed83407cfc7f6a5de3d5b2eb911e8260d172735bc3da0f9830c2ccb2760e964fe9c27ef0fe9b6c58249aada26cb06e46700410759d6b8a0a02261da5e6c400da0218c885b7282c5c716af642a7c47d844518a560a1f8211da7e43c11c843b6927cacbaa6360670ef1bfa61f4d1d8bbcae74c3687cf70fbac7eef3653e9b8d2b214b07d604fe93a535a7ba4103ff7dca7a46a0c31f0195805676998fd26c3f28137a3171e4fdc91c8567a8e44e5412b1e72668ea87f0d343301336c7b07a8e24025a5902f568bf606c36c2eb8330d60508b30427484908b64d451864dfe6a8515b039dc0772b20237a943ab0e7d1f6e043cb788e7e4ddd84fbd23743277740cce7636914e8dde39a72e138d584b76d31f2c2d9f2b8f9d18e94fa16fb79f8c0e7d1425021242977137780f03fcc89de801c8ee21b7947e030886cc05bcd5ac4e533ac62ddc6b96144c32cbf5baa023a3f8121322e733b3d7f11cb503e2c4e664551ae7920e4a96517e3cc9eed193f9c3a3a31b4ea01b977c0aaf469f556425fbc8d269e11eb6b1e15e0b86f428657e4ddd8bb50a5f94052b532a94438f594291880c63fcbf33ff14c395d941b224165bf175227842a1f03f4905d02ed7136a84c351db6b20a67ece1795a84db2f4e6bacd93c36320ae0334eb3cad2cc02e5385717cb5f2f13461bb001936c71a83608b5e016757b5bacc5eac97960bfa88bf0c13e5548c362a3d10d0d302805dded1f1ad78602423167a5f54d0a5f96d1b1b6ff220bb93885fbf9592bfe0f20e273eee25f399b5dc16c935064d0ee5a15f987f2912828df3ad992dc5966c786c3b9af659092c12381f3d4b12b4e21781c916f78452252ee81121786e9c369bf7351bfa47a90c6e6f1478d551d5d4da3937e983315dda117ca5d757c470f26ed81a52a60985075472c2c49bba73de46aa3aa391188792d599d59c5e504e45e3e9fc99ae1bd61a59042fb6695f859826926b251b8d9525b9c277124a759a66ad084f94ff0f5378a8fbe53cf75265fff0f9a8bf6abcf5c1559559c636ba135eff21dc437314ac109ec866d04b63f6e89827c315696357336e438dc10b940a97a956f45e04ae336d665201abf6939c7eb2ce0042064183351aeb1b1ccf7ae15f07181fd5864cd15c4b5791bd5223b513713fc0a9e65dea2eda43945ad81958da1da8dad250d2144cafb09e841555a24b2839834beb053d8d1bb06185c4daffd807d1abdd568e3d7b678401f2ba366e54ccc645ae8dc054096299502445471e8f71df52bd51401555ff5aa4058f9133d4def0031a99a1040a6850c324b2b53d026eff7b132c2081e92f014dd3ae6883c4c947a6c53b5292cc6bc56f47507aa3a0a6237d190b9033f9ef12ded63b4c033e7de4bf6c0100ddb15235eac3b05a07f15fb023bc5c2104e080cef682340c30804376840636e50af77edf8282501888b668bec2545f9e0bfa74a9caaf7e372757e9ed43381c7444c4b2d3ff9e6cf1cde8476e5bbb67ee8383be5395c843cfe926d1a8677e46b4fc50510c0ca99f5419d77a1be41c79c04d92e09908395100d0a762b965eefaae9fc452d0279e27311e88ef0f989eec084e2170872a30bb05ba89a01e051045bca70e22bc3fbb7c6bd5586b8625144516a058c9ec87b74a649162261b2c0b9c641c8fb72fbca80c912d1aeca8532053b815f56354c3483d989fed8d115e2af94032ee3c9b32fdea34861b75d829fc0b151af83c488813f46d949f8375e69a158f58b942bef0c04934128875a1014decc60e3f87fc60e57d9c96d211d4b2387e36ee1128f4713473a126bd277ea87e169e10b72187cde1bab55c37eafb39899a80c3422d57546a5afa0ee5df0abfa819db5763d13d4124efed12931facf3f595d486382f89682b3504edd2b39216151d2592527e0e13536df102ef1d5f063f72eccb0b27f99e14d454534439b733685b35c54ef75744c8487c85796168e4231a87855be56817691b8a34d7e4c79b111f8695d9b85ffe5cadacda57ab5f2ccfc412bea5212b416eb5113925ee370d6ec4ac5b1743102c0ae809e4a3a526941b31a2f290d77ad32bff322cbec17145d9d440ae3785e42bfcab5bc3842e2402db1de2a8cd1c74e1a5edff7ae2f3c6dce46ba945430a7b94e5c3b54dd7bbfa544774318648695f6062a76aacb28b49680271f3c0007c4c5b235f37e5088b6acaf05974d561b4ca4aebea450f78da7d0625daeae25655d788a34984c12699a6935bfeff04f7a6b70f600973a039bc71a8b0440fb86b42decb7ea0dc2cea171176558e17168b97b0925d3e65629e91ae8f6346461da5ca4a2ae59cac341f4ca8e2bcb4206ea71a73dc259465fca9d096557588fed1b97d504d0c29169daef9ca4224f61172444f7b1080b92b183585580027e0e30227204d867437f5c0125c0f70630b8c0579f536181593eb981424d53051765a9d2702275db73760f09dc254af663e5aedef2bbee7cbe2c1363124c79ab7c10a5ac14fc7fde91d7e9617c3163a1312cd6cbf33f338a8d1a1f8f0b53fb30c87e87ab8fa39f28e73366cb3dfb594c18389c6549c3b71141c2c33d805a82a1f3079cfe10530a8e6c20316dc285495a24387e97cdd393e71abc2f345e9448e071b55d0ebeb09c2a8261b95a73152f622de1becc556806aafaae9f9be358691cb22c1a364ea0e5773f22f7ae22fbbb32dbe7b4001b0fbd99dff22c1c3471d7824423ee608cef7be29a99a9fe7d5bd4401ce693cebb3b899429ae2a31177dee89344352f25c2a1f2347e458ea97e7e2117a9b399969150f43651cc0abd94c6d658dadf687378b85ab9ae11cfede987b74f6dc26ff5c2d9e14fe64ab029d55d69f8dc93e097d148e8a3d5f18093e59592ceff5bc56efb6590df6402e163f94b45a4655be4c760f98af07cbf41a5aee8fa56eb4e85f2a4098b991fb062633eed4f43f703f5e3f77ef04c94c6e4ebeb72211c104f05cc3ecf274e5b6db76f70e600acd533284f09e9c3b26152914e60196a570602ed7445028a9305791ffbe375cc37a953ba73d22c0e465b3236eef5b7cb94e5c67c3ab22d862019bfb5e6223e8f3b13e530239062384c53fb3e0329b0de698cfe34207396da7aa27d2d30432095ca8a0fc26ac909914d48f7bfaad9602b5b4dd3a90e87b3c6a1f23d13c9b0268f52754ba87951615b30bab736859914b34a3dd2e96eb22648d6d1ba53cf78bec61ded9004ba9767fcc72ced9815a7111e4bfa37c7157e32d343013c875c847da18477cd3616f1572559628d341707a560ec92dcfeeda35140191c1f89905d953b2a4227d74fc170d0506e484076805248914b10ba8b7bed7dd592eeab37801763734a6b41edb088857f8fa7bd9e2ece41f146db6360dd4875d45d3b07a0115943f287d626817b143603444da1239c52a922dc05c7361b4798bdfda43c3f2584b3d004c2eb285c74f53e812095010bcb23ae6f7d0e2c093ba03c23171499a069b3415f5dde24a03bdeda4bcdcaa34e6cefa176bc1458d82eb7f64e094696b7347768607e71e69765feb08b3e8344a307d6ee5e2725faa2f8238477d265ef991a7649471868abceaa79f376983a9188eac5e430745ed1aee35686bad01ac8830ad998fb9aaef93cffee1a2db8901f2c9cc78653c05c4ecc1b9f94fa20ecc08538f87b59475f08e24c79736e61c7bfb3cf593b129f0b8bd30dcdc8e84bf670b9eeb888d585a289ac80e12d7faaac9d693e500a2f4e159257e506866283f8cef38b28872d164d64acda2f021464b392d386e4e59e96475859f95a88d5d484d433fb7b2e6fb458def3f3fdcb8a7856ec319b6f1bd19a19a37ade429b65f19d651560682392aa6da6c0fa02db40c8d1f6c422eb792c83cbb7c55cff93bb4783850373f615fa86b6921d249a49bc182a665c79bb5f94b84a6f8afb193b8006edfecb81bc77ca4cb71548d43947a0d647265f2f5f704d94f55f0201f8d36769fbc2877ab10a88a45c958e00d74dde8f3ac1a13299ca8966249bf605df72d0a8b4f7e7411c0ff6d76eee3ea28590f6cdf89200fc14d9b61aea068d6a77b860e4938ecd8b93044e3be11734d03d48255d41ba0c01a092832a6509dd3a02c8fa193a2378e45207e0f1a433e0cdb94ec54fe227959815fa88d56324f458e358d85cef822947f713d3c70edb626b3affcfb60565ba8d93fc2373ca564c08c00bb14a4752bf915bf292ede2654bfac274360b7a6aad7e4f60bceb3679b5f650f8309455fbdda9411d2d9f3f9d127a1ee66650e27af6d97554d604253e68bef5020557d62cbb7c219eb603bcf33a3bf2e1dcff279cad8c9742c5933ac11153a0d79b08493238c63b57f656c8c6fe169b453736b961cea661c35d372aab42ef84f2653ffb03dcb73a6e9362569d4aaa17fbd3f83b948df5c34fed507972300626630b9c9cbb44ae5a04eff0afb1e5ae4d59d8b80755bfd1789f9a2fb5ad6357682b690efe14f1cb58d4e55512550651ff3890c8436623f0871386b560fd107c8e9740b31d5a25fc4591a7057faf07d9beb8c682fa2f0961883edcb214c1790ec49d2bbe026dd448895267f045f5d5cb3be88dce6e7b30fcab4c65ffd51d1583f8b8576aa7d68996dd060055ddbc93658457a6219559333957bb54f538b38190a80db639fa8eab8571be5f7146d1296583bd83f8164bdda471176e765a26d2affacd1ee23cb43b8008adc4cb93f278d5f9af7ca0c73a297408af825d5473156c53847eb3807d1a6dbe8b89be11dff580583617879b45de3a66e3e082f9591608e5bb07cc8a5a15a137ea5a2c025a3b942f320bdf1ee9fd082d1328760d53c03064ce37f9aa9a5964c6b75612652a8e473f01928bb573695f9efee34355549ba7a90c47c8a8ad82eddcc87569b777551ed9f3b74fd5a6e602c90ba60ea5f7ab0c8876fd56c63d7c7126a7559b13a0ecd851a02676e2d3b795348d31d8846ccd02943b6f99bbf17b0a19bf336d1da59816de8edb56166a38355e0be1806738c6c754246d358ed1fac5a345e56d88ee4e29083a77c360ea556a951095443981c5b6a9f04384ee1ef9f0c8a627d004aa68f060bd4474bcf16b6365c16bf4d6cad4fd5b3d763d7afc056696f7065a963270ab4234a3c5b1b2c02e8565666e51ce6dc84dc0d92a7aa5ce1f0b46d07dc7e766ff50e3ffc43074aa5fcb004334e2b797bb35f05caea758d15232fc70a782bf4953f8ff671252d9fcdcae10ab428a956edfd24e83c05629669f71ffd6fe622c170c7f14dac29c2716a07713563bb6c40e000d6098d4d46c5c6d85f3d35b45fe57cd9c80ef94f4978b907255c97ce1a51158660194184dbe0059fad0d18389ffd805cb24c945cd668e81a695d21b6a3ee70d951c22e8d21d2126c0640972438626ab78aea17cfac85bf3ca4a1fbfa3753f8ee6afd5b39f376855ec0d492552088d6d33883aa1320c01c746f3c5ea26b9dbd7ac84242405e3f3277b51bbe4ef6a00a5bc5e7732f385613af8e7bb04b90fa332d5d5b5d7eb62330dc30f1faf05045851d7aa3afa7c647dde2c4f2bd95ead78b5fe3222cf3f41070b03dfbbab2379ef399367d9089472bc1f73a49468c07060d47c0d6b2dad500c0c46594c2b62656c5bc0473fa3642c57f48266b11a28a9b3e421678f53d2ad0bc569639c54b491d7e4ff3f5af959632a2e60e1fd86aac51bce7dfa67ba09c2657c4f375ff87223c0eb615532b5793e5d8a8492e0090ef420a2caedc9bcc5e9fa4fb00c481619fffa877cb5d0d943d155a1477bdc4d2f0b1ab81068c8b6f9a01e7dfbbbcc639a0cf535fd8ee1e4ed8aa4e6031cb3f3b73a0e20a5984e4fa44b9607232b8cab19747ed46e516f74b2615ad2c9b390f018bbae9d670308c182f09a7f47bf04f1d16951683c28382ca249b3218065f7de11b295392d179085f2e6ca3cb5265e97f92ecdfed6b40a004be9c181ff372f01348ac26ad56319d8c909edc0eb518987a63cceb0ba86e4e4a9a23cce6b52fc92ecabb9eb588997b4e238e00b50079759438ef6d759dc13786baeac42a302c59a0257ce0b5424a2f6ccd348906041d0c19ec6d85f9e0a15d3cd9fef38f56f157ee5518349e19b1218cf7d068402933b6651af6ed2b54942e6cf50979207d46795266c711c790d0467f1c60a344d4bfb61d217c72bf59e9b3ce3c909ce3ad8837018e84910a60d639644a734cd4813cceac2e8d6594b8763a5bf8b9c60cd27838abfb64a51655fdbe693931a49dec47b5713440ce1122f50ad75d1d91523b1a34f51650eaabb0fd6469a4f57973dc75a0b284aeaea7874b57495816b435285bd228f44d3949814f32e0c159d06c054ebc5b8461ff87c3adcb74f4514a34441386b08b9c9482238a617f48da3c921c5910f6e9310d7bdaf9aca7b026ca096b5ba8f5c56ad8dd6149e313e87084308f84dc9461c63c4032782299b151db801488adb9119148c1773099e308eed48373ecbd1f3e469024b383cd66a01e88bad959e7eed9dc073fa6360c689c9e255bb2bcdfe93a4125b7a6f032cf05b3eaba3a7e8b07a1f39b8eb9372261fce81f791065018dd5554cc585100023b9f3d906aab539e3ec7990d60422856843ca0df6c968f4f3d0f281410f10cf81644f5eaa5095f8be057e64e31718e73993e664a33448294dad86e31a1042f90dcfcaa14d6fcd28d4240c54a6f745c4eca5e962f10c3cf5472c61071c150389f1e25e0349c47ebe18ad490b528dd5b318412e0cee8c073d60bcc82f9dd4d42c5e6184f56c269ac1e838e0b72131a8eeb1e65550e8839235dc0c553a152bfbbbeb1b22d14d6b0c373d764deebd11976965a25d9a43b0acd076b7db1a4d7c5cd4685212fff63dd87f39edbe75cce207f4df14843a07169edd2cb6fb6f285ab5a289f01fc26380b4a438329d11d83c31f00d596c728f8240373a185cb6948a5ee0781f324958586e761845fa511a1bb8cb63a2921ccd21f2a7f8a177baba3c7d04b37985ad0eaabb6f1474a7ebfc5b00cf49d53c191289093fcedac684559254018b4ac2dca50fc601ceb363c2e5f8a52f0d029c37d98be61b5dd40d997d700c816a322309a33723fe65804fde4a71d8e3a1e3551120a90e87ccf9c271b08369481bee08607c1dae71c7a236c40a0126f642098be8e847a14af6cb511a22b56270f89f7121ebfec0cb6e8f135cee1e790c7dce6b733b8d2ed5d806369e9e445eea81492eb7cc09c1f1c3676cff85a75913a4983919cdf23ebfbf2001506bfe618fcafc58147519730ed9acb7a7d3f1a4147ae1ff7e0a02a5876f234c2400be2fac15f95b8295b681f937532617ef62e6a1a6642e2b0625ea8a2fedb11b95ea97e81a242d1a4ce99afead54db3f646f6c93665218f7cb83720b354adfedc8fdad9f04e0ebe340784f17aeda5f8bd056a2c91eb57b501b49e8f0e765c275b5e08c0e5b0ab1286a032ebeaac52c947eb8d998291c84cf7a4966916e3fbc5495b6fc998728102bfde0e0bd982ee358e9eebbd936c76e97ac59851a858f062bc70821fe04ff5433b2c883dff641c014c848ffcb189e8ed486152131d25113d6dfd6e7227f33f7392056ed49076c501a8c1fb76f3cb32669a38624529a9b424c59c51610f558b978ea40b80a86caf98fb01be647c9ebd54793012b8b3feddcf5554fb549a6dfa30e5603ae85367736d4846b5379779133d8089bcaac176d61344ff77eaff444fc3a121b28f6aa70fdcbaa6322c82bbbcfb36c6b0e1130ba7b5927c926e0496fcd73e46c118b1401f060a28144db7234f7e86d72a2e3cb417d4e345c30d6edeafc59767a4a158ffdff73598ed224629c0ea7d9a7293a071f0d8abf968cf481cb4e4792a52b2e765f58cc0de5b495be424aa85d3b7194d70c179db9b442504cf98b8b3fb7417de28cbe5d4f5cfe8334a63d3aff7bce60d863cf09c16118e09aad498a5e44b819f105eba7efcac03fd8af144ce829f789a37b7289369cbb58eb9527aaadf6268de793f9aadd8c634ea09d61eb9a743148c8457c7fa18e311e75935834e9d97c064a4e6b3ea89eeeae2cb55dfe565bbe7261f1ae4c025226373865f644ffcb97b5e130b50085f3e844d719d0525401add33d488dfac90caec69837d7a0eed93f313fe134b0e4779083261b2d95353af34e03b9a236926cf504e92f9292aa430767823aee55439e5e2d44d89b411dc3929eff07dffb31d820bbdd14364583ad0c1ae7d8b87b252599aa7153388acc2bbb596656d728c08b1e50e9255ca0a275d502b0847ec01b3d5b8ea849ff6f7f5ff103d9ca9672865b6bd4d2a64a7674b590782693c7c8059d204f7cc43fe61557ae26e4678b2263d2ecc25b9cb560b29bf1a3a546549c9c09f28ec95667f4a4524518461d7adeb75d56c040a6e78e66d099460fc3322189b750ba504429b899bb87c2c9f92b4993d904798125ff4f9e109d00439448c20e41e09c58a0be94f905b1a99b9d35cef1e703e6d11c8d9d44f7de513e226f7e71558e15a237ef056135d352b74c1d5753a8c823174246b873e4b3b9167eacac08135b6454be45dbf24ac85001a5045ce1727ba7605b2afcf1b20b1644cc964aab54ada97cb6e8ec2a950f6f42b5915285c9ea998b4721f065479ad7a0033b2e39b199d88fcc7254dc2877ff76f29289e861ff2dc60f7e4db61a3bf839d9a3c1c89b02efddeb289d55391a22d12c8085f3510a54d595c88ffb036332a5e536d207037e3fe885076d60db95f1f8cdf46feaf10c0243781de5002874888263f0a58b78f9ad256d9569a19db59c287716cfa5fee4ecfa07d674b990509219f850f496f6e1d890cb02652f3259329e85376f7ce0a427a94dcb931821fc5332d1000a2c7f0118ff602431ec9e033f58d0bcbf633cc2ff1fb896892f9d0b81987749909a661557cd358c6b1bc82d398da10e31c7f66d4db67312fdd5c4b570e86168f1474bce769a6624c0b4102241a2e1002299619201fe577eb23b48d8055ffd8b82607aea61c88546ed0ec367430995d16b5f4242fe4b3e3654eb5acec43bed103a2213fb5053b8f679b4aee0753a94fdb116983b7da5bb058bfc8ec5e009074e6fb69582a1d976a0047f2a4f8d9a78a9c1151dfa97020dfb67fb39ee294f15c2730de31f0b8586dda6ffaac5cf11a5253c919d7926ddc8214aa6e4dc00bbf835bda8663c98100644b1ff947046466d8f5ed7a4f366081aa61d8f403844957cce3a641d1c3ac3a758176ef488163e02dd780917d6bf4ff4d3029c9dd2638fad13bcc2d8aa566ba8f5d50b467346162a03669ad1489fd81a4460dabebc4de1d34776f1a60059449ece82a322839c5da01ccbd0eb5dc55892dc75ed5f06bf371cc457e00e873a2eb4358c7848e7130aa696b38c3f0234a08b2f01615213a0b12f4b7be564ac6d02b9abf31e36be030cd68beb8779786a2977e15db85ee21272fd24c341f1dfee17efebf96294d798459bf2740082fcf61e939ddaa3e5eea8af1b86b5b85266681443e62433798ecd8a26fe745cc46ac9d21d4ddda58f7428f2a9e3bec7df8ae0110f49279a3ffd5e956752bb3f874403a071417bf377e6addeb583434769b11a390b1c0ef8e3ba19d9ee5b8edd5b76f8c3159f340709a0d78e01bb56fef47709bdc45cc0af1862310dda3ba8ceddcfba8cfd806d4d383233f6a7e788c6c656d39f0630bff776bfe231f2e1741deffc8bf77d389c193a8ce25b290ea02a545e0d31802e7b8c422b04d9d2e941e66b74afa7136b3ad3d05dae62e2ed033448fa363a20773ca918d50a1dda4ae9c1b96678f5c72a93b590132e4e9efafc84bf8c9fca7c64521e7ed7a1dc15c2a4398d3a9b111de7d8edb3e41c75871a46ce68fecf21a792c37ecafe72001291b88a41db97bf1723199d62286254ef355f9d086dbcb0e4c92daa4c3fa7057b10821fc14479c2d03fb9d71a2b3894fc281b71fac73610c95adf3c62b776da1708215894b7741d7cd3bb619e7986a3ed1b24b3d6eabf14eb0e49ba5b97555bf49ffd5707aa15378b6ef64642d9ac49a3dd2d6325dd3f35e35277754ed31dbd86b489d674e51b74dc84f03dddd63b39ea7a57d60d611ab3a23484110ee2c673b0d8894420db6eb3f55f14e4ecc3b84808de0259e10bab4b5fa52ad8c742428c7cc7b45504726a060f9819863a94440f541c3ba799456ff16d00baf6c6a2f7ee8f4bd832cf586c6d3b968b41749d866365f87efbfb0d4929943a28470a7e2378a41e98177376dc220cdf454372b28dc3e30b023f34f861556884ac0fcd4e3b330517f08b48564a53cc6b4213f3924514fe22cf9bab9ed534760545bbe74912a596a59f70b3c4781bdcf37ce32c7b0dc2a502c4434b5a1d982b0363619a8d01a96e5b49e191681683e59cd640bd7250061e26c73b78ef0335cec469578f53b478e3ec859073496342f3caa4fdc6d80e27fe0fcdeb72be724a523df9778ac25df5f836e256c91dbe8bf95f136b292cf6857777805a3d22007d269103900d9a4ca1ed76ffa1e2149dd4b6c49cf25b64dbb372e77d2b6f8ca105f30841fbb9c5ef17a97d769475c1e2d51095ba8fed56723d83d467d94419c365305c381bf2abff0edc71701789acaa0cb072e49fa00fedd201e1a30eb408623a3496a7ba02e9b7967b211ac3a9d0e9cd346aa18c498239d64b163d45712194fa0113530a6c58b99dd78980a5f7c14755e2d3a8766c3b05f81c91af2f2370ff2b6d77997edfcc347dd65d7f3d31b17c29d666e9d6d67ac43619af7a129105f1bcd584b323ce08bba876ab165d897acfdf94e5d305775c8975569904f049e16d1c5e3fe8c7fda4fcdabbd07ecd57d6d63f2cf699a84ce0c737b853d1b0e795cc9dfaf0eb6fe9c5f09815f8a1edc81e7f1ff18d4c615c6ef20c6d8e0fa833085beea55d7fb28d2f411d26adc46183ad889de2ff57994d9f77961f95294dfe547b711d76b7436bb1fa2a6e4f25a608aa1772eff053b5ebf349a2bbce1d38a04ef9295e430a0cd5a6e2eb498c51850573a9e58782537596cb22f0db31a49ac23bb0fddefb77f2a57cb33b5edddcee9f902e312ac815765bfd8f8d75574d4d41e0c1a87332a04a454d5761a9a81d853e6eaf173bcacdac9ceed7b2c6f49b0e0160cfd72764166ad1850680c5ac6fbdc2a9beebca10379e11124fcf8b107de295ac3b2f5f1bc376aa9181a6340e0e39b0d18a14b5e98e7adee8642163502e31463aefcde0f07ffbe479bca7bb716971e38334d4ca7a50848ece0959888e2db9025028ada2d3e245caa22a7f0afe41278865bcd089752d2837e53a21c2579a3b457b03c88c6c09d87a2d5f0880b2ad1b47c6ca66fc1fd4253b1180ca5d397344640aa4a2584724f8e12120112176f126f72002042d7796665fd3312b05ef53db79315ae445426aa57c77679d09f3aff9d6c53eee8358a2f2ce0f46cc3f1cae532f1ca07a95a85fe843c6053b30260693ba92d9c019a1306c818384b726150ca83f0d96ffc80a27fdfa95fbc0190dd0f758c2e6343bf960c29b479abfac2f1dcad62d86e5dbbf0f6a4909e7c1a1d2251d675fc0a2cafa83eb8999f300cf9cf70cba4fcbf1c432b42854abbfc6d296b210b002a84f615b7a8d5a96591dfca824f63c1d1f229ad065fcfca8ddfd39a7fc614aea3e6549e61b6833590f162368a7ad9496aedfa3dc540301c35da3ed4bb0c7b062d12a4351499d3fff3a7d7150d7da60e01ec0396b481ffae5e7a1d480c61bbaffe271138dfcb9db16cd80cd41e929f24e3f92d7c71beb23238ba357ed4f87e1565a1055cc76fc541466cbbe76632fb15a6600a45ff8c41e198fdc24ad960aae19a8618a954e6fec52936a8b723113fed0eb386ce32eee8aa3fc17ae9aa1451aadc62a0c9088b4c7a2332cf242a48218bd24a709c31054b31e2d498d796cd796a6550a308f3cc271192060a4fe22e7708e12f80d3e661f888a0700af93be395aa6d2cbc50fa22007dc7ab76748c4f1b0a587d627399301ab025ad73033a8a6dfff6f1888a28b33f261d28ac0ca2d86b1128c7cb830fdbfa79920996855880c9f326c1dfa652263bb48608dacf6be0cf2544b8173d2d0eed06decd1d087da035fb50fd7b083b91e7c3795dc7adf02c4fea05a9ec8910a85736767697b5a75acb33fc07db015f4283f26330f11e0d3c1e119548ca12055f01983f68c3ea06fdde371866d4d177a7ed8e4be5486866c0d1b949c9d004c5825a0e7d927e38b6b18a1da7c289c0db10ad4c8f86506bd55d81f06594f696e512419b2a03ae86eeb06b8813b614890e5d7ac58f5969051b09e63d9450ccb360a6a5f609c525401fcc58c83b2b06976ab4486c58bceeed046a250dd25964614be7a7fe04e11d31332a1968221bc5e53a39f1a9fdc593ce70e79320c6d3b73d22819cbc148a3b2e4ca1f69eabfe745162f3477d6f374a321bac49f71cec8b77bccc29553fe03861449b0dcded2c29362d08f6ad96af6cb82667d058a88f32dafe7d256b1ae32634de3a501fdd727ad4fd699454c5e902afa9638338d0467e40f7f55dcb272c24886870b8031ee972c3aad4d68616595c077d626eb2337144d83a39191203f89340c70266655fcc0fc721943ed74e16dec474adac41e088e2c631122a42f9bc619b56e46e5885df3fc666df8b6855c47764e83362ee0bed55dc9b98c3b586216c1a25d7598b68d92a4b562f4e24953cdbcd83c0ff68ca4495ddedc5febe40f9b4c29726092bf39d9a437cdf4dce9b6bd3afa14074f6c9f11ee5c6a38f8e302f8d46d04db25f714ed2b94fb8338b4fa325bf6a3a5affff52c290d4e38a277b8ae2683fd6e8ce9e9f03529dfd0adbe49de93caf4aa25c9ea0703a1a7c32ad61cab1ec856a3223d9d6521a5d759fbec9b0bfe96be81409b73ebe1e356cbcc470dcfebd00ed12d9fb9aad274d87609e324f97e85f5fe9d629d494ad995e0d1d51b12c1c64b85994f790314c4b34a8a2ed7b3007d2524e7cd6d53f41e6a2e135dc23d3699eba5c7bd12a629cbc377f0a16c486cc9b1f6b6b702dcae5ee34e782d75e42046afeb9fab62364ccc4f6c7c86a9b7be97372071a2e16129e684bb07168416bf96ea81881558f62bb79d8493c96aea0e430c2d53be2350791ddf8d855c829aa1516a1286b8d828b127fa844de92df844eb79da008f66a3e0c16740e5848f1681341202c96bb913c663190920293ffd4eb65c24dd894c62b6d167549f69302c717ed9ef6196bc932824e762b58a8f6facf40abcf7be6912ebe9d2490ea0895abfba239f847671d2668f1481e4ea3b1d62d035f172aa58d342b009a84dbb2b7c4acfd2942ead44c013f62808fdfe06f7e6b2033b0ef6a782c50a11ffaac40cc11a7ff27dbe495ac501189e87a6bf3b5207257825c2b01fa2c78ccc31c184a3710b7ead349193b79f37b9c130a3b78239dba4c9b7413d4f0330257a0d0d64ad6f60f8dd8f3dace3a0c3789fe294a0af1adf0ca6c8980aee53eb6238aefbbc0841d686b93499f4bafb213564510579e984d6d4f983e042270c17ec3cdfb7747a8438a787bf550519653be356c3512efd69e49d93eec3e91bd9beeb3a6cc372ee203f558badd504d4cb405a2186a26caa2ff391486a09ac47083fa90f144ad318da362a522bce9dfdedeee7145715fc513232f1b613d4c34ab14b523a4ade637bacbf7ed62e60a41c1b236a650a1b0d94eec8c2a236ff853f1d0989ac7bfa731febdba6959fbbc45272c52dbb0497f86634e5c3615597c57e9c188bdaf22b39dcc7675d30a4f4874b3078c4340829e82bd107846480c5fd25c2e62be9be4effd47497410c75995d5fc169e3a6520d9a0280bcc9fc12ff3f42a6f724ad2ef4c977ce1df137e114e68baf87414a46446dca84d16cc68bcaee38e2ee46ded4f4166b46e4b4cf8169f129d4bf739109c78c276b99efc2e7a7f279e514619785bc467ede80eb00f4e7fb1be5fc16cf20121af8da3362acf05769fe5b1fd7c83a4d2d882fdf1354ddc690e9222ed648550934b23cec9e83691eaca064c18104b22fb16c8f915b9aa6f63d17929325a7ae8fd0ca8b639f24bc247c8bf0f2a18fa855454c3ff9262fd9b0ab4ecb0223e08c29a99f6f5b2876880d199e93370c4fe1e697f73d74ab4e0b3aab149be51f6596960878045b4d7d2dfb2f72877f042a21011afddd5b1945b3c87787944c8d8ceb1f5853696bf16e59ac99d24050286da8e4b1d7f1661a74f49a27b90b509732f5f42d95c6cc609da74fcb2875ad8825ad433e74241ce99b7164a66f2badc300741de9ff69508323b708db6ee46073c61e904b70970ae14c0edf76424827a32565d260edab3956a74114b0d22f3857d0324d85f33d29e5287da528b77eb22abd8b03f5fb560d192e510ba5f96ae2d2ba96a40af47d4ecabbfeede6a1d7a4ea82cbc3b89311f4ca1c3cfdb33dc23cb92ab934361b2ed0e13577fe0997208df7dc25fddc3cfb92f6cc79330d0f5cc45f65891011aeb4e930aabbfee87bc50b65afd877c9dcaa63343861c9902fd5f2eec0d24a39937160415e070392b6b82d08f9a7bd68975534fd81ca4f9087bd9ec4b851cb8697a365c817e3da221b7f34124f598f73da71fdcae06c41e41dd2abb636f74f2efbf13900913a160854cd358f60f4b4edccb56c02ae071ca8873f2eea8bf024f005e846604484073cc6ecc13893ba519a2897d3bfae8f7d2c50427546589ed331698b05ed10dc3936cf037ecca2fbff6b285a22f4fc73327543380c843ae0340b31d23175a57ba11108ac1fb2c81be47cf149cc1e531b78be8b0e1dd6489895e6349dcc19d3dbf516cf1664a8d05bc0d9e4392450c90422bc907daa226529698622c246ba6cce67ff936ea7fbd5b9bf1b8c9178680aa51a9766e03b760c26f5845b6873f2157a87dcf5022e7b80ff0d146c79cc63735985de20c2137a79a85a573072c0ad641c51699bb7e78d68b01c43a798b26bc3dbc37e4039e73abd2437f6993363f4e1e04bc7a272cf7d655ca4040607a5d53fd75ac43c587ee1bad361f5a2b17d3abfeeeceaf072768156fd974035b2392c50a5af0bcfb7b8dd38954884ac7ec3413a9b1646da8191218d0cd64d523b324352f285a415185cf5d7c15745fb2261965b9dcce5386f76668d337ad8185fb7397ea2ed589ee948de184a941f5bfb0f328f2d7f03ec8d5e03c51821292feb326576ae1fa358e323676ff077955e5813890707a1ccd4a2a33db2a2c13daca40e4ddeef82d026f1491820ac329c53192660105f6ba02af8a9253b64c9355007d0f58a79ab95b2100803654bc94c7b12d545f81b060dadb2dde755c6cec6eb011b54c8c0424ef1cafd8eed639ccf0c83a7cdf0cdcb8c2e9c2eb8c69313c4485e40b4ed0e629210a4b326d9babb8c6d37f8d7f9f3052dd052c0f0a014bba2111f97033ad0228e2e49a8a3dac2b934893afba84b250fce834b8673c6a25ee70e0fe033097c9642b21a187bb2ec440deebc17a752f9e0a0dcbc0827a7ee9ea1a4b7f1d4cbc5aa46af0a2b21bd66444","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
